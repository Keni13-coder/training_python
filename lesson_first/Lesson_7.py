'''
Задача No47. Решение в группах
У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине программы используется множество раз и вы не хотите ничего сломать):
transformation = <???>
values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
transormed_values = list(map(transformation, values))
Единственный способ вашего взаимодействия с этим кодом - посредством задания функции transformation.
Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, а нужно получить его как есть.
Напишите такое лямбда-выражение transformation, чтобы transformed_values получился копией values.
Пример ввода и вывода данных представлены на следующем слайде
Задача No47. Решение в группах
Ввод:
values = [1, 23, 42, ‘asdfg’]
transformed_values = list(map(trasformation, values)) if values == transformed_values:
print(‘ok’) else:
print(‘fail’)
Вывод:
ok
'''
# def task47(array):
#     return 'Ok' if list(map(lambda x: x,array)) == array else 'Fail'

# print(task47([1, 23, 42, 'asdfg']))
'''
Решение в группах №49
Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовем самой далекой планетой ту, орбита которой имеет самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits), которая среди списка орбит планет найдет ту, по которой вращается самая далекая планета. Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, зато искусственные спутники были были запущены на круговые орбиты. Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса. Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса. При решении задачи используйте списочные выражения. Подсказка: проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, а затем найти и сам эллипс, имеющий такую площадь. Гарантируется, что самая далекая планета ровно одна
Пример ввода и вывода данных представлены на следующем слайде
Решение в группах
Ввод:
orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)] print(*find_farthest_orbit(orbits))
Вывод:
2.5 10

'''
# from functools import reduce
# def task49(array):
#     return max(array , key=lambda x: reduce(lambda z,y: int(z *y) if z != y else 0,x))


# def find_farthest_orbit(orbits):
#     return max(orbits, key=lambda x: (x[0] != x[1]) * x[0] * x[1])


# orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3), (100, 100)]
# print(*find_farthest_orbit(orbits))


# print(task49([(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]))



'''

Напишите функцию same_by(characteristic, objects), которая 
проверяет, все ли объекты имеют одинаковое значение 
некоторой характеристики, и возвращают True, если это так. 
Если значение характеристики для разных объектов 
отличается - то False. Для пустого набора объектов, функция 
должна возвращать True. Аргумент characteristic - это 
функция, которая принимает объект и вычисляет его 
характеристику.
Ввод: Вывод:
values = [0, 2, 10, 6] same
if same_by(lambda x: x % 2, values):
print(‘same’)
else:
print(‘different’)
'''


def task51(arary):
    return 'different' if len(set(map(lambda x : x % 2 , arary))) > 1 else 'same'



print(task51([0, 2, 10, 6]))



'''
Написать функцию, которая принимает список строк и возвращает список строк, 
содержащих только одно слово, с использованием лямбда-функции:
strings = ["Hello", "This is a sentence.", "Another sentence"]
'''


def ttt(array):
    return max(array, key= lambda x: len(x.split()) == 1)


print(ttt(["This is a sentence.", "Hello",  "Another sentence"]))


'''
Вводится список целых чисел в одну строчку через пробел. Необходимо оставить в нем только двузначные числа. 
Реализовать программу с использованием функции filter.
Результат отобразить на экране в виде последовательности оставшихся чисел в одну строчку через пробел.

'''

def tt1(array):
    return list(filter(lambda x: len(str(abs(x))) == 2,array))



print(tt1([-8, 11, 0, -23, 140, 1]))


'''
Дан список, вывести отдельно буквы и цифры.

a = ( "a", 'b', '2', '3' ,'c')
b = ( 'a' , 'b' , 'c')
c = ( '1', '2', '3')
'''

def tt2(array):
    ls = []
    return [x for x in array if x.isdigit()],[x for x in array if x.isalpha()]


print(tt2(["a", 'b', '2', '3' ,'c']))
'''
Вводится натуральное число N. С помощью list comprehension сформировать двумерный список размером N x N, состоящий из нулей, а по главной диагонали - единицы. (Главная диагональ - это элементы, идущие по диагонали от верхнего левого угла матрицы до ее нижнего правого угла). Результат вывести в виде таблицы чисел как показано в примере ниже.

Sample Input:
4
Sample Output:
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
'''
import numpy as np
def ttt1(N):
    # ls = []
    # first=0   
    # for x in range(N):
    #     ls.append([1 if i == first else 0 for i,v in enumerate(range(N))])
    #     first += 1

    # return np.matrix(ls)
    return np.matrix([[1 if i == j else 0 for j in range(N)] for i in range(N)])

print(ttt1(4))
